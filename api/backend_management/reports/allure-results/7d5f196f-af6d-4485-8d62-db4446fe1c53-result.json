{"name": "test_customer_create_booking", "status": "broken", "statusDetails": {"message": "TypeError: Booking() got unexpected keyword arguments: 'class_id'", "trace": "@allure.feature('Customer Booking Management')\n    @allure.story('Create a Booking via Customer Method')\n    @pytest.mark.django_db\n    def test_customer_create_booking():\n        with allure.step(\"Create a PaymentSystem instance\"):\n            payment_system = PaymentSystem.objects.create(\n                system_name='PayPal',\n                api_endpoint='https://api.paypal.com'\n            )\n        with allure.step(\"Create a Coach instance\"):\n            coach = Coach.objects.create(\n                name='Mike Johnson',\n                specialization='Badminton',\n                contact_info='mike.johnson@example.com'\n            )\n        with allure.step(\"Create a BadmintonClass instance\"):\n            badminton_class = BadmintonClass.objects.create(\n                name='Pro Badminton',\n                description='Professional level training',\n                price=150.00,\n                coach=coach,\n                court_type='Outdoor',\n                racket_count=10\n            )\n        with allure.step(\"Create a Customer instance\"):\n            customer = Customer.objects.create(\n                name='Alice Brown',\n                email='alice.brown@example.com',\n                phone='123-456-7890'\n            )\n        with allure.step(\"Prepare payment details\"):\n            payment_details = {\n                'payment_system_id': payment_system.id,\n                'payment_method': 'Credit Card',\n                'status': 'Completed'\n            }\n        with allure.step(\"Customer creates a booking\"):\n>           booking = customer.create_booking(\n                class_id=badminton_class.id,\n                schedule_date=timezone.now() + timezone.timedelta(days=7),\n                payment_details=payment_details\n            )\n\nuser\\tests\\test_book_tiyu.py:113: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nuser\\models\\book_tiyu.py:55: in create_booking\n    booking = Booking.objects.create(\nD:\\Anaconda\\envs\\pyflink\\lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nD:\\Anaconda\\envs\\pyflink\\lib\\site-packages\\django\\db\\models\\query.py:677: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Booking: Booking None by Alice Brown>, args = ()\nkwargs = {'class_id': 2}, cls = <class 'user.models.book_tiyu.Booking'>\nopts = <Options for Booking>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002DA785C24A0>, val = 1\nfield = <django.db.models.fields.related.OneToOneField: payment>\nis_related_object = False, property_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Booking() got unexpected keyword arguments: 'class_id'\n\nD:\\Anaconda\\envs\\pyflink\\lib\\site-packages\\django\\db\\models\\base.py:567: TypeError"}, "steps": [{"name": "Create a PaymentSystem instance", "status": "passed", "start": 1733659475069, "stop": 1733659475193}, {"name": "Create a Coach instance", "status": "passed", "start": 1733659475193, "stop": 1733659475254}, {"name": "Create a BadmintonClass instance", "status": "passed", "start": 1733659475254, "stop": 1733659475378}, {"name": "Create a Customer instance", "status": "passed", "start": 1733659475378, "stop": 1733659475442}, {"name": "Prepare payment details", "status": "passed", "start": 1733659475442, "stop": 1733659475442}, {"name": "Customer creates a booking", "status": "broken", "statusDetails": {"message": "TypeError: Booking() got unexpected keyword arguments: 'class_id'\n", "trace": "  File \"C:\\Users\\zongjunyi\\PycharmProjects\\llm-projects\\backend_management\\user\\tests\\test_book_tiyu.py\", line 113, in test_customer_create_booking\n    booking = customer.create_booking(\n  File \"C:\\Users\\zongjunyi\\PycharmProjects\\llm-projects\\backend_management\\user\\models\\book_tiyu.py\", line 55, in create_booking\n    booking = Booking.objects.create(\n  File \"D:\\Anaconda\\envs\\pyflink\\lib\\site-packages\\django\\db\\models\\manager.py\", line 87, in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n  File \"D:\\Anaconda\\envs\\pyflink\\lib\\site-packages\\django\\db\\models\\query.py\", line 677, in create\n    obj = self.model(**kwargs)\n  File \"D:\\Anaconda\\envs\\pyflink\\lib\\site-packages\\django\\db\\models\\base.py\", line 567, in __init__\n    raise TypeError(\n"}, "start": 1733659475442, "stop": 1733659475818}], "start": 1733659475069, "stop": 1733659475822, "uuid": "f8c9a4d0-5f55-43d2-a928-f82d9fc29ee0", "historyId": "f7a09e755d14bba2fa15ca8001a12de7", "testCaseId": "f7a09e755d14bba2fa15ca8001a12de7", "fullName": "user.tests.test_book_tiyu#test_customer_create_booking", "labels": [{"name": "feature", "value": "Customer Booking Management"}, {"name": "story", "value": "Create a Booking via Customer Method"}, {"name": "tag", "value": "django_db"}, {"name": "parentSuite", "value": "user.tests"}, {"name": "suite", "value": "test_book_tiyu"}, {"name": "host", "value": "SHPatsnapB0008"}, {"name": "thread", "value": "44792-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "user.tests.test_book_tiyu"}]}